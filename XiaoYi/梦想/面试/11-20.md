#### 说说ArrayList和LinkedList
1. ArrayList是基于数组，而另一个基于双向链表
2. 随机访问优于LinkedList，O(1),LinkedList：O(n)
3. 增删改：LinkedList要优于ArrayList
4. LinkedList比ArrayList更占内存，因为Linked节点除了存储数据还存储两个引用
#### 数据库为什么不用红黑树而用B+树
1. 首先,红黑树是一种近似平衡二叉树（不完全平衡）,结点非黑即红的树,它的树高最高不会超过 2*log(n),因此查找的时间复杂度为 O(log(n)),无论是增删改查,它的性能都十分稳定； 但是,红黑树本质还是二叉树,在数据量非常大时,需要访问+判断的节点数还是会比较多,同时数据是存在磁盘上的,访问需要进行磁盘IO,导致效率较低； 
2. B+树是多叉的,可以有效减少磁盘IO次数；同时B+树增加了叶子结点间的连接,能保证范围查询时找到起点和终点后快速取出需要的数据。 
3. 加分回答 红黑树做索引底层数据结构的缺陷 试想一下,以红黑树作为底层数据结构在面对在些表数据动辄数百万数千万的场景时, 索引从根节点开始查找,而如果我们需要查找的数据在底层的叶子节点上,那么树的高度是多少,就要进行多少次查找,数据存在磁盘上,访问需要进行磁盘IO,这会导致效率过低； 那么红黑树作为索引数据结构的弊端即是：树的高度过高导致查询效率变慢。
#### MySQL的事务隔离级别
1. 四种隔离级别：READ UNCOMMITED、READ COMMITED、 REPEATABLE READ、SERIALIZABLE（可串行化）
2. 如下表格
| 隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
|:-------- |:---------- |:---------------- |:---------- |:------ |
| 读未提交 | Yes        | Yes              | Yes        | No     |
| 读提交   | No         | Yes              | Yes        | No     |
| 可重复读 | No         | No               | Yes        | No     |
| 串行化         |No            |No                  | No            |Yes        |

1. InnoDB存储引擎默认的支持隔离级别是REPEATABLE READ,但是与标准SQL不同的是,InnoDB存储引擎在REPEATABLE READ事务隔离级别下,使用Next-Key Lock的锁算法,因此避免了幻读的产生。,InnoDB存储引擎在默认的事务隔离级别下已经能完全保证事务的隔离性要求,即达到SQL标准的SERIALIZABLE隔离级别
2. READ UNCOMMITTED： 它是性能最好、也最野蛮的方式,因为它压根儿就不加锁,所以根本谈不上什么隔离效果,可以理解为没有隔离。
3. SERIALIZABLE： 读的时候加共享锁,其他事务可以并发读,但是不能写。写的时候加排它锁,其他事务不能并发写也不能并发读。
4. REPEATABLE READ & READ COMMITTED： 为了解决不可重复读,MySQL 采用了 MVVC (多版本并发控制) 的方式
5. 

