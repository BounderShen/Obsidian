#### 请说说线程和进程的区别(空间、切换、并发性、独立、内存、崩溃)
1. 进程有独立的地址空间，线程有自已的堆栈和局部变量，但线程之间没有单独的地址空间
2. 进程和线程切换的时候，需要切换进程和线程的上下文，进程的上下文切换时间开销远远大于线程切换上下文的时间，耗费资源较大，效率要差
3. 线程的并发性比进程高
4. 每个独立的进程都有一个程序运行的入口，顺序执行序列和程序的出口，但是线程不能独立运行，必须依存在应用程序中，由应用程序提供多个线程执行控制
5. 系统在运行的时候会为每个进程分配不同的内存空间，而对线程而言，除了CPU之外系统不会为线程分配内存，系统不会为线程分配内存（线程所使用的资源来自所属进程资源）线程组之间共享资源
6. 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程组崩溃整个进程都死掉，所以多进程较健壮
#### 说说Mysql索引，以及他们的好处和坏处
1.  索引主要有普通索引、唯一索引、主键索引、外键索引、全文索引、复合索引几种
2. 不仅能大幅提高匹配where条件的检索效率,还能用于排序和分组操作的加速
3. 比如索引必定会增加存储资源的消耗；同时也增大了插入、更新和删除操作的维护成本,因为每个增删改操作后相应列的索引都必须被更新
4. 创建索引一定走索引码？使用组合索引，没有遵从最左前缀（id,name,age）；如果最左不是id是不会使用组合索引
#### 请你说说多线程
1. 线程是操作系统调度的最小单元,它可以让一个进程并发地处理多个任务,也叫轻量级进程。所以,在一个进程里可以创建多个线程,这些线程都拥有各自的计数器、堆栈、局部变量,并且能够共享进程内的资源。由于共享资源,处理器便可以在这些线程之间快速切换,从而让使用者感觉这些线程在同时执行。
2. 更多的CPU核心 现在的计算机主要向多核心发展,所以处理器的核心数量会越来越多,充分地利用处理器的核心则会显著地提高程序的性能。而程序使用多线程技术,就可以将计算逻辑分配到多个处理器核心上,显著减少程序的处理时间,从而随着更多处理器核心的加入而变得更有效率
3. 更快的响应时间 我们经常要针对复杂的业务编写出复杂的代码,如果使用多线程技术,就可以将数据一致性不强的操作派发给其他线程处理（也可以是消息队列）,如上传图片、发送邮件、生成订单等。这样响应用户请求的线程就能够尽快地完成处理,大大地缩短了响应时间,从而提升了用户体验
4. 更好的编程模型 Java为多线程编程提供了良好且一致的编程模型,使开发人员能够更加专注于问题的解决,开发者只需为此问题建立合适的业务模型,而无需绞尽脑汁地考虑如何实现多线程。一旦开发人员建立好了业务模型,稍作修改就可以将其方便地映射到Java提供的多线程编程模型上。
#### 说说怎么保证线程安全
1. 常用的三种线程安全方式：原子类、volatile、锁
2. 原子类提供了用法简单、性能高效、线程安全地更新一个变量的方式。atomic包提供了17个类，按功能区分为：原子更新基本类型、原子更新引用类、原子更新属性、原子更新数组。无论哪种都遵循“比较替换原则“，比较更新的值是否等于期望的值，如果是则更新，否则失败。
3. volatile是轻量级的同步，在多处理器开发中保证了共享变量的”可见性“，从而保证单个变量读写时的线程安全。可见性的问题是由处理器核心缓存导致的，每个核心都有各自的缓存，这些缓存要与内存进行同步。Volatile具有以下语义：当写一个volatile变量时，该线程本地内存中的共享变量会被立刻刷新到主内存；当一个读volatile时，该线程本地内存会被设置为无效，被迫使线程直接从主内存中读取共享变量。
4. 原子类和volatile只能保证单个共享变量的线程安全,锁则可以保证临界区内的多个共享变量的线程安全
5. JDK的开发团队在1.5新增了Lock接口,并通过Lock支持了上述的功能,即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）
6. 额外
	1. 无状态设计：线程安全问题是由多线程并发修改共享变量引起的,如果在并发环境中没有设计共享变量,则自然就不会出现线程安全问题了。这种代码实现可以称作“无状态实现”,所谓状态就是指共享变量
	2. 不可变设计：如果在并发环境中不得不设计共享变量,则应该优先考虑共享变量是否为只读的,如果是只读场景就可以将共享变量设计为不可变的,这样自然也不会出现线程安全问题了。具体来说,就是在变量前加final修饰符,使其不可被修改,如果变量是引用类型,则将其设计为不可变类型（参考String类）
	3. 并发工具：Semaphore：就是信号量,可以控制同时访问特定资源的线程数量。 - CountDownLatch：允许一个或多个线程等待其他线程完成操作。 - CyclicBarrier：让一组线程到达一个屏障时被阻塞,直到最后一个线程到达屏障时,屏障才会打开,所有被屏障拦截的线程才会继续运行
	4. 本地存储：使用ThreadLocal存储变量,ThreadLocal可以很方便地为每一个线程单独存一份数据,也就是将需要并发访问的资源复制成多份。这样一来,就可以避免多线程访问共享变量了,它们访问的是自己独占的资源,它从根本上隔离了多个线程之间的数据共享
#### 说说死锁定义及发生的条件
1. 死锁 两个或两个以上的进程在执行过程中,因争夺共享资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。
2.  2. 产生死锁的必要条件 虽然进程在运行过程中,可能发生死锁,但死锁的发生也必须具备一定的条件,死锁的发生必须具备以下四个必要条件：
	1. 互斥条件：即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源,则请求者只能等待,直至占有资源的进程用毕释放；
	2. 请求和保持条件：指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已被其它进程占有,此时请求进程阻塞,但又对自己已获得的其它资源保持不放
	3. 不剥夺条件：指进程已获得的资源,在未使用完之前,不能被剥夺,只能在使用完时由自己释放；
	4.  环路等待条件：指在发生死锁时,必然存在一个进程——资源的环形链,即进程集合 {P0,P1,P2,···,Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源,……,Pn 正在等待已被 P0 占用的资源
#### 说说对MVC的理解
1.  MVC是一种设计模式,在这种模式下软件被分为三层,即Model（模型）、View（视图）、Controller（控制器）
2. Model代表的是数据,View代表的是用户界面,Controller代表的是数据的处理逻辑,它是Model和View这两层的桥梁。将软件分层的好处是,可以将对象之间的耦合度降低,便于代码的维护。
3. Model：指从现实世界中抽象出来的对象模型,是应用逻辑的反应；它封装了数据和对数据的操作,是实际进行数据处理的地方（模型层与数据库才有交互）。在MVC的三个部件中,模型拥有最多的处理任务。被模型返回的数据是中立的,模型与数据格式无关,这样一个模型能为多个视图提供数据,由于应用于模型的代码只需写一次就可以被多个视图重用,所以减少了代码的重复性
4. View：负责进行模型的展示,一般就是我们见到的用户界面。 Controller：控制器负责视图和模型之间的交互,控制对用户输入的响应、响应方式和流程；它主要负责两方面的动作,一是把用户的请求分发到相应的模型,二是把模型的改变及时地反映到视图上。
5. Spring MVC框架已经成为了MVC模式的最主流实现。 Spring MVC框架是基于Java的实现了MVC框架模式的请求驱动类型的轻量级框架。前端控制器是DispatcherServlet接口实现类,映射处理器是HandlerMapping接口实现类,视图解析器是ViewResolver接口实现类,页面控制器是Controller接口实现类
#### 说说乐观锁和悲观锁
1. 乐观锁总是假设最好的情况,每次去拿数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型,这样可以提高吞吐量**,像数据库提供的类似于write_condition机制,其实都是提供的乐观锁。
2. 悲观锁：悲观锁总是假设最坏的情况,每次去拿数据的时候都认为别人会修改,所以每次在拿数据的时候都会上锁,这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用,其它线程阻塞,用完后再把资源转让给其它线程）
3. 额外
	1. 悲观锁： 悲观锁的好处在于可以减少并发,但是当并发量非常大的时候,由于锁消耗资源、锁定时间过长等原因,很容易导致系统性能下降,资源消耗严重。因此一般我们可以在并发量不是很大,并且出现并发情况导致的异常用户和系统都很难以接受的情况下,会选择悲观锁进行。
	2. GIT,SVN,CVS等代码版本控制管理器,就是一个乐观锁使用很好的场景,例如：A、B程序员,同时从SVN服务器上下载了code.html文件,当A完成提交后,此时B再提交,那么会报版本冲突,此时需要B进行版本处理合并后,再提交到服务器。
#### 说说内存管理
1. Linux 操作系统是采用段页式内存管理方式： 页式存储管理能有效地提高内存利用率（解决内存碎片）,而分段存储管理能反映程序的逻辑结构并有利于段的共享
2. 将这两种存储管理方法结合起来,就形成了段页式存储管理方式。段页式存储管理方式即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名。在段页式系统中,为了实现从逻辑地址到物理地址的转换,系统中需要同时配置段表和页表,利用段表和页表进行从用户地址空间到物理内存空间的映射。 系统为每一个进程建立一张段表,每个分段有一张页表。段表表项中至少包括段号、页表长度和页表始址,页表表项中至少包括页号和块号。在进行地址转换时,首先通过段表查到页表始址,然后通过页表找到页帧号,最终形成物理地址。
#### 对IOC的理解
1.  IoC是控制反转的意思,是一种面向对象编程的设计思想。在不采用这种思想的情况下,我们需要自己维护对象与对象之间的依赖关系,很容易造成对象之间的耦合度过高,在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题,它可以帮我们维护对象与对象之间的依赖关系,并且降低对象之间的耦合度
2. 说到IoC就不得不说DI,DI是依赖注入的意思,它是IoC实现的实现方式。由于IoC这个词汇比较抽象而DI比较直观,所以很多时候我们就用DI来代替它,在很多时候我们简单地将IoC和DI划等号,这是一种习惯。实现依赖注入的关键是IoC容器,它的本质就是一个工厂。
#### hashcode和equals方法区别，为什么重写这两个方法
1. hashCode()方法的主要用途是获取哈希码,equals()主要用来比较两个对象是否相等。二者之间有两个约定,如果两个对象相等,它们必须有相同的哈希码；但如果两个对象的哈希码相同,他们却不一定相等
2. Object类提供的equals()方法默认是用==
#### @Autowired和@Resource注解的区别
1. @Autowired是Spring提供的注解，另一个是JDK提供的
2. @Autowired只能按类型来注入，@Resource默认按名称注入，也支持类型注入
3. @Autowired按类型装配依赖对象，默认情况下要求依赖对象必须存在，如果允许null值，可以设置为require属性为False,想用名称装配要结合@Qualifier注解一起使用。@Resource两个重要属性：name和type。如果没有指定指定name属性,当注解标注在字段上,即默认取字段的名称作为bean名称寻找依赖对象,当注解标注在属性的setter方法上,即默认取属性名作为bean名称寻找依赖对象。 
4. 加分回答 @Resource装配顺序 
	1. 如果同时指定了name和type,则从Spring上下文中找到唯一匹配的bean进行装配,找不到则抛出异常 
	2. 如果指定了name,则从上下文中查找名称（id）匹配的bean进行装配,找不到则抛出异常 
	3. 如果指定了type,则从上下文中找到类型匹配的唯一bean进行装配,找不到或者找到多个,都会抛出异常 
	4. 如果既没有指定name,又没有指定type,则自动按照byName方式进行装配；如果没有匹配,则回退为一个原始类型进行匹配,如果匹配则自动装配；
