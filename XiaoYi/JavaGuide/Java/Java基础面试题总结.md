#### Java语言有哪些特点
1. 面向对象（封装、继承、多态）
2. 支持多线程
3. 可靠性、安全性
4. 支持网络编程并且很方便
5. 编译与解释并存
#### 什么是字节码？采用字节码的好处是什么？
1. 扩展名为.class文件，只面向虚拟机
2. 编译->.class文件->解释器&JIT->机器可理解的代码
3. JIT是属于运行时编译，当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用
4. HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用
#### 为什么不全部使用AOT

1. CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 `.class` 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器
#### BCL协议和OTN协议
1. 支持商用但是不能修改
2. 可以私下使用但是不能修改

#### Java和C++区别
1. Java不提供指针直接访问内存，程序内存更加安全
2. Java的类是单继承的，C++支持多重继承
3. Java有自动内存管理垃圾回收机制
4. C++同时方法重载和运算符重载
#### 移位运算符
1. 左移运算符：高位丢弃，低位补零
2. 右移运算符：高位补运算符，低位丢弃
3. 无符号右移：忽略符号位，空位都以0
4. 移位操作符实际上支持的类型只有int和long
#### 移位的位数超过数值所占右的位数会怎样？
1.对应的进行求模
### 变量
#### 成员变量与局部变量的区别
1. 语法形势：成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被public、private、static等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；
2. 存储方式：从变量在内存中的存储方式来看,如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存
3. 生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡
4. 默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值
#### 静态变量有什么作用？
1. 静态变量可以被类的所有实例共享。通常会被final进行修饰成常量
#### 字符型常量和字符串常量的区别？
1. 形式：字符常量时单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字
2. 含义：字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)
3. 占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节
4. char在Java中占用2个字节
#### 静态方法为什么不能调用非静态成员？
1. 静态方法是属于类，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作
#### 重写和重载的总结
|   区别点	|   重载方法	|   重写方法	|
|---	|---	|---	|
| 发生范围  	|   必须修改	|   子列	|   
|  参数列表 	|   可修改	|   一定不能修改	|   	
|   返回类型	|   可修改	|   子类方法返回类型比父类小或者相等	|   
| 异常| 可修改|子类抛出的异常应比父类方法声明抛出的要小或相等|
| 访问修饰符| 可修改|一定不能更严格的限制，可以降低限制|
|发生阶段 | 编译期| 运行期|
### 基本数据类型
#### Java中的几种基本类型了解吗？
1. Boolean,官方文档定义，依赖于JVM厂商的具体实现。逻辑上占用1位，但是实际上会考虑计算机高效存储因素。
#### 基本类型和包装类型的区别
1. 成员变量包装类型不赋值就是NULL，而基本类型有默认值不是NULL
2. 包装类型可用于泛型，而基本类型不可以
3. 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中
4. 相比于对象类型，基本数据类型占用的空间非常小
#### 包装类型的缓存机制了解吗？
1. Byte、Short、Integer、Long、这四种类型默认创建了[-128,127]的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean直接返回True Or False
2. 所有整型包装类型对象之间值的比较，全部使用equals方法比较
#### 自动装箱与拆箱了解吗？原理是什么？
1. 默认调用了valueOf方法
2. 拆箱时使用了：xxxValue方法
#### 为什么浮点数运算的时候会有精度丢失的风险
1. 计算机是二进制的，在表现一个数字时，宽度是有限的，无限循环小数存储在计算机时只能被截断
#### 如何解决浮点数运算的精度丢失的问题
1. BigDecimal可以实现对浮点数的运算。涉及钱的场景使用这个类来做
#### 超过long整型的数据应该如何表示
1. 基本数值类型有一个表达范围，超过就会有数值溢出的风险
2. BigInteger内部使用int数组进行存储任意大小的整型数据
## 中
### 面向对象和面向过程的区别
1. 过程：把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题
2. 对象：抽象出对象，使用对象的方法进行解决问题
#### 创建一个对象用什么运算符？对象实体与对象引用不同
1. new运算符，创建的实例是在堆内存中，对象引用指向对象实例（存放在栈内存中）
#### 对象的相等和引用相等的区别
1. 对象的相等一般比较的是内存中存放的内容是否相等
2. 引用相等一般比较的是指向的内存地址是否相等
#### 构造方法有哪些特点，是否可以被重写
1. 名字与类名相同
2. 没有返回值，但不能用void声明构造函数
3. 生成类的对象时自动执行，无需调用
4. 不能被重写，能被重载
#### 面向三大特征
##### 继承
1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
3. 子类可以用自己的方式实现父类的方法
#### 多态
1. 对象类型和引用类型之间具有继承（类）/实现（接口）的关系
2. 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定
3. 多态不能调用“只在子类存在但在父类不存在”的方法
4. 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法
#### 接口和抽象类有什么共同点和区别
##### 共同点
1. 都不能被实例化
2. 都可以包含抽象方法
3. 都可以有默认实现的方法（Java 8 可以用关键字在接口中定义默认方法）
#### 区别
1. 接口主要用于对类的行为进行约束，你实现了某个接口就具有对应的行为。抽象类主要用于代码复用，强调的是所属关系
2. 一个类只能继承一个类。但是可以实现多个接口
3. 接口中的成员变量只能是public static final类型的，但不能被修改必须有初始值，而抽象类的成员变量默认default，可在子类中被重新定义，也可以被重新赋值
#### 深拷贝和浅拷贝？什么是引用拷贝
1. 浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象
2. 深拷贝会完全复制整个对象，包括这个对象所包含的内部对象
3. clone方法只能复制当前对象
### Java常见类
#### equals方法存在两种使用情况
1. 类没有重写equals方法：通过equals比较该类的两个对象时，等价于比较两个对象
2. 类重写了equals方法：重写方法来比较两个对象中的属性是否相等；若属性相等，则返回true
3. 
#### hashCode有什么用？
1. 获取哈希码，确定对象在哈希表中的索引位置
2. 是本地方法，用C语言或者二C++实现，将对象的地址转换为整数之后返回
#### 什么要有hashCode
1. 把对象加入HashSet时，会计算对象的哈希码并进行比较，没有相符这不重复，有相同会进行equals进行比较
2. 如果不同散列到其他位置，大大减少了equals的次数
#### 为什么JDK同时提供两个方法
1. 在一些容器中，有哈希码之后，判断元素是否存在容器中效率大大提高
#### 为什么有两个哈希码相同，它们也不一定相同
1. 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关
2. 
#### 为什么重写equals时必须重写hashcode方法
1. 两个相等的对象的 `hashCode` 值必须是相等
### String
#### String、StringBuffer、StringBuilder的区别
##### 可变性
1. String 底层是用final修饰的char类型数组
##### 线程安全习性
1. String是不可变的，线程安全
2. StringBuffer对方法加了同步锁，而StringBuilder没有所以是非线程安全的
##### 性能
1. 对String类型进行改变的时候，都会生成一个新的String对象，然后指针指向新的String对象。StringBuffer对对象本身进行操作，不是生成新的对象并改变对象引用。相同情况下使用StringBuilder比StringBuffer不仅能获得10%~15的提升，但要冒多线程不安全的风险
#### 为什么String不可变
1. 保存的字符数组为final修饰且为私有，并且String类没有提供/暴露修改这个字符串的方法
2. String类被final修饰导致其不能被继承，进而避免了子类破坏String不可变
#### 字符串常量池的作用了解吗？
1. 字符串常量池是JVM为了提升性能和减少内存消耗针对字符串专门开辟的一块区域，主要目的是避免了字符串的重复创建
#### String s1 = new String("abc")；这句话创建了几个字符串对象？
1. 字符串常量池不存在字符串对象”abc“的引用，那么会创建2个字符串对象
2. 存在：则创建一个
#### String类型的变量和常量做"+"运算时会发生什么？
1. **对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化**
2. 折叠编译条件：
	1. 基本数据类型和字符串常量
	2. final修饰的基本数据和字符串变量
	3. -   字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）
4. **引用的值在程序编译期是无法确定的，编译器无法对其进行优化**
