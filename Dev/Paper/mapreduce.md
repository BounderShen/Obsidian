#### 摘要
MapReduce是一种编程模型和相关实现，用于处理和生成大数据集。用户指定一个map函数来处理键/值对以生成一组中间键/值对，以及一个reduce函数来合并与同一中间键关联的所有中间值。许多真实世界的任务都可以在这个模型中表达，如论文所示。使用这种功能风格编写的程序会自动并行化，并在大量普通计算机群集上执行。运行时系统负责分区输入数据、调度程序跨一组机器执行、处理机器故障和管理所需的机器间通信等细节。这使得没有任何并行和分布式系统经验的程序员可以轻松利用大型分布式系统的资源。
我们MapReduce实现运行在大规模普通计算机群集上，并具有高可扩展性：典型的MapReduce计算可以在数千台计算机上处理数TB级别的数据。程序员发现该系统易于使用：已经实施了数百个MapReduce程序，并且每天有超过1000个MapReduce作业在Google集群上执行。
#### 1.介绍
在过去的五年中，谷歌的作者和许多其他人实现了数百个特殊用途计算，处理大量原始数据（如爬取文档、Web请求日志等），以计算各种派生数据，例如倒排索引、Web文档图形结构的各种表示形式、每个主机爬取页面数量的摘要、给定日期内最常见查询集合等。大多数这样的计算在概念上都很简单。然而，输入数据通常很大，并且必须将计算分布在数百或数千台机器上才能在合理时间内完成。如何并行化计算、分发数据和处理故障问题共同使得原本简单的计算变得复杂起来。

作为对这种复杂性的反应，我们设计了一个新抽象层次结构，允许我们表达我们试图执行但隐藏了并行化、容错性、数据分发和负载平衡混乱细节中所涉及到的简单运算库。我们抽象层次受Lisp和许多其他函数语言中存在map和reduce基元启示而来。我们意识到，我们大部分运算都涉及将map操作应用于输入中每个逻辑“记录”，以便计算一组中间键/值对；然后将reduce操作应用于所有共享相同键的值，以便适当地组合派生数据。我们使用具有用户指定map和reduce操作的函数模型，可以轻松并行化大型计算，并将重新执行用作容错的主要机制。

这项工作的主要贡献是一个简单而强大的接口，使得大规模计算的自动并行化和分布成为可能，并结合了这个接口的实现，在普通PC集群上获得高性能。
第2节描述了基本编程模型并给出了几个示例。第3节描述了MapReduce接口在我们基于集群的计算环境中量身定制的实现。第4节描述了我们发现有用的编程模型几个细化方面。第5节对我们实现各种任务时进行性能测量。第6节探讨Google内部使用MapReduce以及将其作为重写生产索引系统基础时所遇到经验。第7节讨论相关和未来工作。

#### 2.编程模型
计算过程接受一组输入键/值对，并生成一组输出键/值对。MapReduce库的用户通过两个函数来表达计算：Map和Reduce。
由用户编写的Map函数接受一个输入对并产生一组中间键/值对。MapReduce库将所有与相同中间键I相关联的中间值分组在一起，并将它们传递给Reduce函数。
也由用户编写的Reduce函数接受一个中间键I和该键的一组值。它合并这些值以形成可能更小的值集合。通常每次调用Reduce只会产生零个或一个输出值。通过迭代器向用户提供了中间结果，从而可以处理无法放入内存的大型数列数据。
##### 2.1例子
考虑在大量文档中计算每个单词出现次数的问题。用户将编写类似以下伪代码的代码：
map(String key, String value):
// key: document name
// value: document contents for each word w in value:
EmitIntermediate(w, "1");
reduce(String key, Iterator values):
// key: a word
// values: a list of counts int result = 0;
for each v in values: result += ParseInt(v);
Emit(AsString(result));
map”函数会发出每个单词及其出现次数的计数（在这个简单的例子中只有“1”）。 “reduce”函数将特定单词发出的所有计数相加。
此外，用户编写代码填充一个MapReduce规范对象，其中包含输入和输出文件的名称以及可选调整参数。然后，用户调用MapReduce函数，并传递给它该规范对象。用户的代码与MapReduce库（用C++实现）链接在一起。附录A包含了此示例的完整程序文本。
##### 类型
尽管之前的伪代码是以字符串输入和输出为基础编写的，但用户提供的映射和归约函数在概念上具有相关类型：
map         (k1,v1)        → list(k2,v2)
reduce    (k2,list(v2)) → list(v2)
输入键和值来自不同的域，而输出键和值则来自另一个域。此外，中间键和值与输出键和值来自相同的域。
我们的C++实现将字符串传递给用户定义函数，并由用户代码在字符串和适当类型之间进行转换。
##### 更多的例子
以下是一些简单的有趣程序示例，可以轻松地表示为MapReduce计算。

分布式Grep：map函数如果匹配了提供的模式，则发出一行。reduce函数是一个恒等函数，只将提供的中间数据复制到输出。

URL访问频率计数：map函数处理网页请求日志并输出hURL, 1i。reduce函数将相同URL的所有值相加，并发出hURL, 总数i对。

反向Web链接图：map函数针对在名为source的页面中找到目标URL的每个链接输出htarget, sourcei对。reduce函数连接与给定目标URL相关联的所有源URL列表，并发出该对:htarget, list(source)i

每个主机术语向量：术语向量总结了文档或一组文档中最重要单词作为hword，frequencyi对列表。 map 函数针对每个输入文档（其中主机名从文档 URL 中提取）发出 hhostname、term vector 对。 reduce 函数传递给定主机的所有按文件分割后各自生成 term vectors 。它们将这些项合并起来，丢弃不常见项，然后发出最终 hhostname、term vector 对。
倒排索引：映射函数解析每个文档，并发出一系列的单词、文档ID对。规约函数接受给定单词的所有对，排序相应的文档ID并发出一个单词、列表（文档ID）对。所有输出对的集合形成了一个简单的倒排索引。很容易扩展这个计算来跟踪单词位置。

分布式排序：映射函数从每条记录中提取键，并发出一个键、记录对。规约函数不改变所有配对关系。此计算依赖于第4.1节描述的分区设施和第4.2节描述的排序属性。

![](E:\IT\图片\Snipaste_2023-03-26_23-15-01.png)

#### 3.实现
MapReduce接口有许多不同的实现方式，正确的选择取决于环境。例如，一个实现可能适用于小型共享内存机器，另一个则适用于大型NUMA多处理器系统，还有一种则适用于更大规模的网络机群。

本节描述了针对Google广泛使用的计算环境而设计的一种实现：由交换式以太网连接在一起的廉价PC集群[4]。在我们这个环境中：
(1) 机器通常是运行Linux操作系统、配备2-4GB内存、采用双处理器x86架构。
(2) 使用普通网络硬件——通常是每台机器100兆比特/秒或1千兆比特/秒，但总体二分带宽要低得多。
(3) 集群由数百或数千台机器组成，因此机器故障很常见。
(4) 存储由直接连接到各个单独机器上的廉价IDE硬盘提供。我们自主开发了一个分布式文件系统[8]来管理这些硬盘上存储的数据。该文件系统使用复制技术，在不可靠硬件之上提供可用性和可靠性保证。
(5) 用户将作业提交给调度系统。每个作业包含一组任务，并由调度程序映射到集群中的一组可用机器。
##### 3.1执行概述
Map调用通过自动将输入数据分成一组M个拆分来在多台机器上进行分布式处理。不同的机器可以并行处理输入拆分。Reduce调用通过使用一个划分函数（例如，hash(key) mod R）将中间键空间划分为R个部分来进行分布式处理。用户指定了划分数（R）和划分函数。
图1显示了我们实现中MapReduce操作的整体流程。当用户程序调用MapReduce函数时，会发生以下操作序列（图1中编号标签对应于下面列表中的数字）：

1. 用户程序中的MapReduce库首先将输入文件拆成通常每个片段16兆字节到64兆字节大小的M份（可由用户通过可选参数控制）。然后，在一组计算机集群上启动许多程序副本。
2. 程序副本之一是特殊的——主节点。其余都是工作节点，由主节点指派任务给它们。需要指派M个map任务和R个reduce任务。主节点选择空闲工作节点，并为每个工作节点指派一个map或reduce任务。
3. 被指派执行map任务的工作节点读取相应输入拆件内容，并从其中解析出键/值对，并将每对传递给用户定义的Map函数进行处理生成中间键/值对并缓存在内存中。
4. 定期地，缓冲区内部产生的键/值对被写入本地磁盘，并通过划分函数将其划分为R个区域。这些缓冲区内部产生的键/值对在本地磁盘上的位置会传回给主节点，由主节点负责将这些位置转发给reduce工作节点。
5. 5. 当一个reduce工作进程被主节点通知这些位置时，它使用远程过程调用从映射工作进程的本地磁盘读取缓冲数据。当一个reduce工作进程读取了所有中间数据后，它按中间键对其进行排序，以便将相同键的所有出现分组在一起。排序是必要的，因为通常许多不同的键映射到同一个reduce任务。如果中间数据量太大无法放入内存，则使用外部排序。
6. reduce工作进程遍历已排序的中间数据，并针对每个唯一的中间键遇到时，将该键和相应集合的中间值传递给用户定义Reduce函数。 Reduce函数输出附加到此减少分区的最终输出文件上。
7. 当所有map任务和reduce任务都完成后，主节点会唤醒用户程序。此时，在用户程序中MapReduce调用返回到用户代码。

成功完成后，MapReduce执行结果可在R输出文件（每个减少任务一个文件，并由用户指定文件名） 中获得。通常情况下，用户不需要将这些R输出文件合并成一个文件 - 他们经常将这些文件作为输入传递给另一个MapReduce调用或从能够处理分成多个文件 的其他分布式应用程序使用它们 。
##### 3.2主数据结
主节点维护了多个数据结构。对于每个映射任务和归约任务，它存储了状态（空闲、进行中或已完成）以及工作机器的身份（对于非空闲任务）。
主节点是中间人，通过它，从映射任务到归约任务传播中间文件区域的位置。因此，对于每个已完成的映射任务，主节点存储了映射任务生成的R个中间文件区域的位置和大小。随着映射任务的完成，位置和大小信息的更新被接收。信息被逐步推送到具有正在进行的归约任务的工作机器。
##### 容错
由于MapReduce库旨在使用数百或数千台机器处理大量数据，因此该库必须能够优雅地容忍机器故障。

***工作机器故障***
主节点定期向每个工作机器发送ping请求。如果在一定时间内没有收到来自工作机器的响应，则主节点将该工作机器标记为故障。由该工作机器完成的任何映射任务都将被重置回其初始空闲状态，因此可以在其他工作机器上进行调度。同样，正在失败的工作机器上进行的任何映射任务或归约任务也将被重置为空闲状态，并可以重新进行调度。

由于已完成的映射任务的输出存储在失败机器的本地磁盘上，因此无法访问，因此在故障发生时需要重新执行已完成的映射任务。而已完成的归约任务不需要重新执行，因为其输出存储在全局文件系统中。
当映射任务首先由工作机器A执行，然后由工作机器B执行（因为A失败），所有执行归约任务的工作机器都会收到重新执行的通知。任何尚未从工作机器A读取数据的归约任务将从工作机器B读取数据。

MapReduce对大规模工作机器故障具有弹性。例如，在一次MapReduce操作期间，正在运行的集群上进行网络维护，导致每次80台机器变得无法访问，持续数分钟。MapReduce主节点简单地重新执行不可达到的工作机器所完成的工作，并继续向前推进，最终完成了MapReduce操作。
***主故障***
很容易让主节点定期写入上述主数据结构的检查点。如果主节点任务死亡，则可以从最后一个检查点状态开始启动新副本。但是，考虑到只有一个主节点，其故障不太可能发生；因此，我们当前的实现在主节点故障时会中止MapReduce计算。客户端可以检查此条件，并在需要时重试MapReduce操作。

当用户提供的映射和归约运算符是其输入值的确定性函数时，我们的分布式实现会产生与整个程序的非故障顺序执行所产生的输出相同的输出。

我们依赖于映射和归约任务输出的原子提交来实现这一属性。每个正在进行的任务将其输出写入私有临时文件。一个归约任务产生一个这样的文件，而一个映射任务产生R个这样的文件（每个归约任务一个）。当映射任务完成时，工作机器会向主节点发送消息，并在消息中包含R个临时文件的名称。如果主节点收到一个已经完成的映射任务的完成消息，则会忽略该消息。否则，它会将R个文件的名称记录在主数据结构中。当归约任务完成时，归约工作机器会原子地将其临时输出文件重命名为最终输出文件。如果同一个归约任务在多台机器上执行，则将为同一个最终输出文件执行多个重命名调用。我们依赖于底层文件系统提供的原子重命名操作来保证最终文件系统状态仅包含一次执行归约任务所产生的数据。
##### 系统交互

我们设计了系统以最小化主节点在所有操作中的参与。在此背景下，我们现在描述客户端、主节点和块服务器如何交互以实现数据变异、原子记录追加和快照。

###### 3.1 租约和变异顺序

变异是改变块的内容或元数据的操作，例如写入或追加操作。每个变异都在所有块的副本中执行。我们使用租约来维护跨副本的一致变异顺序。主节点授予一个块租约给其中一个副本，我们称之为主副本。主副本为所有变异选择一个序列顺序。所有副本在应用变异时都按照这个顺序进行。因此，全局变异顺序首先由主节点选择的租约授予顺序定义，然后在租约内由主副本分配的序列号定义。

租约机制旨在最小化主节点的管理开销。租约有一个初始超时时间为60秒。但只要块正在变异，主副本就可以无限期地请求和通常接收主节点的扩展。这些扩展请求和授权是通过主节点和所有块服务器定期交换的心跳消息搭载的。主节点有时可能会在租约到期之前尝试吊销租约（例如，在主节点要重命名的文件上禁用变异时）。即使主节点失去与主副本的通信，它也可以在旧租约到期后，安全地向另一个副本授予新租约。

在图2中，我们通过按照这些编号步骤跟踪写入的控制流程来说明这个过程。