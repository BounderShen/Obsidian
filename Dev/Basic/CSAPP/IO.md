### Unix I/O
#### Unix概述
1. Linux文件是一串顺序的字节
2. 所有IO设备都是文件
3. 内核也是一个文件（内核镜像、内核数据结构）
#### 常规文件

1. 常规文件包含随意的数据
2. 应用通常区分：文本文件和二进制文件，但内核不知道
3. 文本文件是文本行的序列

#### 目录

1. 目录由一系列链接数组组成
   1. 每一个链接将文件名映射到文件
2. 每个目录至少包含两个条目
   1. 它自已和它的父目录
3. 内核每个进程当前的工作目录

#### 打开文件

1. 打开文件通知内核做好准备访问文件
2. 返回一个小的身份符，
   1. -1发生错误

#### 关闭文件

1. 关闭一个已经关闭的文件会发生异常
2. 总是检查返回码，

#### 读文件

1. 从当前位置将字节复制到内存上，然后更新文件位置
2. “返回从文件fd中读取的字节数，并将它们放入buf缓冲区中。
3. 读取不够，会继续读取剩下的

#### 写文件

1. 复制到内存并更新位置
2. “返回从buf缓冲区中写入文件fd的字节数。”
#### 短计数
##### 发生场景
1. 遭遇EOF读取
2. 从终端读取文本行
3. 读写网络套接字
##### 未发生场景
1. 从磁盘读取文件
2. 写入磁盘
### RIO(robust I/O)package
#### The RIO Package
1. RIO 是一组包装器，为应用程序提供高效和鲁棒的 I/O，例如网络程序，这些程序可能会受到短计数的影响。
##### 两种函数
1. 未缓存：输入输出 字节数据（rio_readn and rio_writen）
2. 缓存:只提供了输入（文本和字节）```rio_readlineb and rio_readnb```
3. 缓冲的 RIO 过程是线程安全的，并且可以在同一个描述符上任意交错使用。
#### 未缓存 RIO 输入和输出
##### 使用通过的接口：```unix  read and write```
##### 用于在网络套接字上传输数据
1. 读会返回短计数，写不会返回
#### 缓存输入读取
##### 从部分缓存在内部内存缓冲区中的文件中高效地读取文本行和二进制数据。
1. `rio_readlineb` 从文件描述符 `fd` 中读取一个最多包含 `maxlen` 个字节的文本行，并将该行存储在 `usrbuf` 中。
2. 停止条件
	1. ```maxLen bytes read ```
	2. 遇到EOF
	3. 遇到换行
#### 缓存输入（con）
1. **rio_readnb** reads up to **n** bytes from ﬁle **fd**
2. 停止条件
	1. ``` maxLen bytes read```
	2. ``` EOF encounted```
3. 可以在同一描述符上任意交错使用 `rio_readlineb` 和 `rio_readnb`。
	1. 不要与```rio_readnb ```交错使用

### Metadata,  sharing,  and  redirection
#### 文件元数据
1. 文件元数据被内核维护
### Standard  I/O
#### 标准输入输出流
1. 作为一个流，
#### 缓存动机
1. 应用单次只读一个字符
2. 实现Unix IO 调用是昂贵的
3. 
### Closing  remarks
#### Unix I/O
##### PRO
1. Unix I/O 是最通用和最低开销的 I/O 形式。
2. 所有IO包都是基于此实现的
3. 提供函数访问文件的元数据
4. Unix I/O 函数是异步信号安全的，可以在信号处理程序中安全地使用。
##### Cons
1. 处理短计数是棘手的，容易出错。
2. 高效读取文本行需要某种形式的缓冲，这也是棘手的，容易出错。
3. 这两个问题都可以通过标准 I/O 和 RIO 包来解决。
#### 标准IO
##### Pros
1. 缓冲可以通过减少读取和写入系统调用的次数来提高效率。
2. 短计数被自动处理
##### Cons
1. 不提供函数访问元数据
2. 标准 I/O 函数不是异步信号安全的，并且不适用于信号处理程序。
3. 标准 I/O 不适用于网络套接字上的输入和输出。
	1. 流上存在文档不完善的限制，这些限制与套接字上的限制相互作用会导致问题。
##### 什么时候使用标准输入输出
1. 尽可能使用高层次的输入
2. 当需要在磁盘或者终端工作时

