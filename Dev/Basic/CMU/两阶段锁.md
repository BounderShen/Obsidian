#### 锁类型
1. lock管理器不一定会持有该lock的时间长度有所限制
2. 取决于事务，确保当事务完成的时候，回过头释放这个lock,接着更新内部元数据
#### 两阶段锁
1. 它允许数据库系统始终以保证Conflict Serializable schedule的情况下来分发lock
2. 两阶段：Growing获取所需要的所有的锁，执行所有的操作，然后释放该锁，并告诉lock管理器，我⽤完这个lock了，这个事务就会处于Shrinking阶段，不能再获取锁了
3. 遵从两阶段锁会得到Conflict Serializable的schedule，保证依赖图无环
4. 会发生级联中止：一个条事务访问了另一个事务修改后的值，事务的值没有提交，所以应该是不可见的，导致另一条事务，这条事务也会中止。从而增加逻辑回滚的复杂性
##### 强严格两阶段锁
1. 直到提交事务的时候才需要释放锁。所有锁都会在事务结束的时候释放掉
###### 为什么会发生中止？
1. 
#### 死锁检测和预防
1. 使用检测算法来发现死锁，或者主动出击
2. 死锁其实就是事务间彼此依赖成环，它们都在等待对⾯释放它们所需要的锁
##### 死锁检测
1. 使用后台线程去查看lock管理中的元数据，构建一个Wait-for图
2. 每⼀条线会指向另⼀个节点，该节点持有着另⼀端那个节点想要获取的锁。出现环则死锁
3. 陷入死锁状态，想让这些事务等待的时间有多长？在不检测死锁的情况下，我陷⼊死锁状态的可接受时常是多少？这些都是可以在数据库系统中进行调整的参数
4. 不同workload会有不同的死锁行为
##### 受害者选择
1. 通过时间戳、已经完成的工作量、或者已经执行查询的数量、拿了多少个锁
2. 不一定需要使用强严格两阶段锁，取决于workload是什么？如果这些workload并不容易导致cascading aborts或者脏读的情况。两阶段锁
3. 应该考虑某个事务已经被重启的次数：因为确保系统有进展，防止饥饿情况
4. 不一定要完成中止，可以最小化的中止，做事务回滚，脱离死锁。这取决于workload是什么？以及要丢弃多少工作，重新递交事务它们所有的查询这是否有意义，或者慢慢释放锁
5. 如果在应⽤程序层，你能通过⾃⼰的逻辑去推断出这些东⻄,如果这样做提⾼了你的系统性能，那你可以降低隔离级别,对于强严格两阶段锁来说我们需要使⽤它来确保我们不会遇上任何脏读导致的cascading aborts问题
6. psql：如果系统进入死锁状态，我会去查询catalog，它能够显示哪些事务持有着锁，它们在等待哪些锁，锁属于哪些事务和线程
##### 死锁预防
1. mysql只做检测，不进行预防，psql检测速度较慢
2. 根据时间戳来分配优先级，老的事务优先级高
3. wait-die：老的事务等待年轻的事务；如果requesting transaction具备更⾼的优先级，holding transaction要⽐它年轻，但这个年纪较⼤的事务想获取它⼿上的锁，这个requesting transaction就会原地等待获取这把锁，否则这个请求事务就会被中止
4. wound-wait情况：requesting transaction拥有⽐holding transaction更⾼的优先级，requesting transaction拥有⽐holding transaction更⾼的优先级
###### 哪种场景下，我们总是想去干掉时间戳最小的情况
1. 取决于workload是什么？引起死锁的原因，以及在什么场景下会引起的死锁问题
#### 层级锁
1. 简单来讲，你会在树的较⾼层处使⽤intention lock，以此来提示其他事务你会在该系统的较 低层⾯做什么事情
2. 它会试着增加该系统的并⾏性
3. shared+intention-exclusive：在这个节点上有⼀个显式的shared lock，在⼦树下⽅的所有东⻄上，你都会有⼀个与之对应的shared lock，在⼦树下⽅的某处地⽅。你也会有⼀个显式的exclusive lock：这意味着说我读这里所有的值，但我也会在某个地方进行修改（x锁）
##### 锁协议
1. 为了获得⼀个shared lock，你⾄少得在⽗节点处提示下，你有⼀个intention-shared lock
2. 对于exclusive lock也是如此，为了获取⼀个exclusive lock或intention-exclusive lock或shared+intention-exclusive lock，你需要在⽗节点处加⼀把intention-exclusive lock
##### 多锁保证
1. 多个线程访问情况下：T1对节点加了shared + intension-exclusive lock；T2想访问表中某个元组，则意味着去获取intension-shared lock；T3想要读取所有数据，需要去获取表share lock，但不能只能等待，因为表中正在执行写操作
2. 这可以减少锁的数量，并减少锁的请求数量，
3. 可以升级锁；目的是在减少Lock管理器的工作量以及不违反两阶段，所以可以在不释放锁的情况下 对锁进行升级
4. 在真正的系统中，你不会坐在那⾥并告诉系统该对哪个tuple上锁，你可以给出提示
5. 如果你知道你要对⼀张表进⾏⼀系列操作，在执⾏的过程中，你想⼀直拿着锁，你不能显式锁住这张表
##### `select for update`
1. 读取某个元组最终想要对其进行更新，可以给数据库一个暗示，表示我正在读取，等下要更新，去获取一个写锁
#### 隔离级别
