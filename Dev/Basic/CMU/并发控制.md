#### 前言
##### strawman system
1. 同一时间只有一个事务在DBMS运行
2. 复制整个数据库到新的文件，成功重写到源文件，否则丢失
#### 原子性
##### 确保原子性的机制
1. 日志方案：预写式⽇志之类的东⻄，但实际上，我们会将⽂件记录在磁盘上。对于数据库修改来说，会先对制作一个副本，防止崩溃或者事务中止的情况
2. 在内存和磁盘中，我们都要去维护这些Undo Record，如果当我们执⾏事务的时候，事务被中⽌了，如果这些Undo Record是放在内存中的，那我们就能很快将修改过的部分变回原来的值。当我们再打开数据库系统的时候，我们可以将这些保存在磁盘上的⽇志记录加载回来，并使我们回到正确的状态
3. 通过⽇志，我们可以将随机写⼊变成循序写⼊，这会使得系统跑得更快。对于其他应⽤程序来说，实际上，⽇志可以⽤来跟踪审计你应⽤程序所做的每⼀件事
4. 影子页面：制作数据库文件的副本，将修改放在副本上进行，只需要将指针指向这个副本即可，表示现在这个副本
###### 事务中止
1. 因为如果这些⽇志信息是在内存中的话，如果事务中⽌了，那么我可以迅速从内存中获取到这些信息，并将数据变回原状
2. 如果我遇上的是hard crash，并且这些⽇志信息是在磁盘上，加载系统备份的时候，可以将这些数据恢复原状
###### 是否需要将读取事务写入到磁盘上
1. 如果不在意丢数据的话，可以将它写入到磁盘上
2. ，shadow paging其实就是多版本并发控制的⼯作⽅式
###### 每当事务提交的时候，我是否得进⾏同步并将它刷到磁盘上
1. 是的，但你不需要对每次提交都进⾏这种操作，你可以将它们累积在⼀起，当你要将它们都刷出去的时候，你可以做⼀次组提交
2. 棘⼿的地⽅在于你将这些数据写⼊磁盘的顺序是什么，在你将该data page写⼊磁盘前，你需要先确保你写⼊的⽇志记录对应着该data page上的⼀ 次修改操作
3. 他们会每隔60秒将数据刷回磁盘，如果你发⽣了崩溃，你也就只是丢掉最后60秒的数据
#### 一致性
1. 但只要数据完整性和引⽤完整性之类的东⻄都是正确的就
2. Database Consistency（数据库⼀致性）和Transaction Consistency（事务⼀致性）
3. 对帐号更新，1ms后你在另⼀台物理机上对同⼀个逻辑数据库中的数据进⾏了⼀次读操作。如果我已经告诉外界，我的事务已经提交了，那么你应该能够看到我所做的修改
4. 
##### 事务一致性
1. 它⾥⾯不应存在邮箱后缀为@cmu.edu的客户账号，然后，我的事务会尝试去做这件事（知秋注：添加⼀条这个后缀的客户账号数据）。我⽆法在我的数据库中阻⽌这件事情的发⽣
2. 
#### 隔离性
1. 如果⽤户提交了许多事务，我们想让每个事务⾃⼰做⾃⼰的事。我们之所以希望提供这种保障，对数据库具有独占访问权限。我们不需要关⼼我们从其他事务中所读取到的任何中间值
2. 
##### 确保隔离的机制
1. 每个事务都会有⾃⼰的本地变量，事务彼此之间不会共享这些变量
##### 事务内部
1. 如果我们需要跑到磁盘上去获取某个东⻄，或者等待获取某个对象的latch，我们可以让其中⼀个事务停下来。另⼀个事务继续执⾏，并取得了⼀些进展
2. 我们要确保当我们对任意对象进⾏读或者写操作的时候，如果另⼀个事务也在做相同的操作。我们始终会通过正确的执⾏顺序来判断我们的调度是否正确
##### 正确性
1. Serial Schedule：逐个执行事务，而不是交错执行它们
2. 等效策略指的是：如果数据库中这些对象的最终状态是相等的。或者是，它和另⼀个数据库状态中的值是相等的。那么，它们的执⾏效果就是相同
3. Serial Schedule是包含在具有正确结果的Ordering Schedule之中的，我不确定到底是其 中的哪⼀个，但它们最终都会有⼀个相同的状态
4. 但对于⼀个给定的Schedule来说，它可能是正确的，它可能依然是Serializable的，它等价于任何可能的Serial Ordering Schedule
5. 如果该schedule的执⾏结果等于按顺序执⾏的结果,那么，不管我们看的这个schedule是什么，它都是Serializable的
##### 冲突操作
1. 来自不同的事务，在同一个对象上，至少一个是写的状态
###### 读写冲突
1. 也可以叫做不可重复读，当试着去读取同一个东西，看到的结果始终是不同的
###### 脏读
1. 这时临时不一致，对A进行修改，以此提交到数据库，但所有人都不应该看到这个修改。因为未提交这个事务，因为中止事务，向外界暴露了本不该出现的信息
######  写写冲突
1. 覆写掉未提交的数据
2. 会发生撕裂更新
##### 序列化冲突直觉
1. 通过交换那些不冲突操作的顺序来弄清楚该Schedule是否是Conflict Serializable
2. 思路：通过交换操作的执行顺序，确保和顺序执行的效果一样
3. 交换成本太高
##### 依赖图
1. 查看调度生成依赖表，存在一个环图，那么就不是序列化的，因为不能够进行交换顺序，不存在则是conflict serializable
2. 存在环则不是冲突序列化
#### 持久性
##### 项目3
1. 构建catalog
2. 
