#### 前言
##### 多版本并发控制
1. 我们维护的是这些对象的不同物理版本，⽽不是为每个事务创建⼀个私有⼯ 作空间
2. 当事务进⼊系统的时候，我们要给它们分配时间戳，接着，当事务到达的时候，我们会为事务提供该数据库的⼀份⼀致的snapshot（快照）。这意味着，它们不会看到那些还未在它们快照中进⾏提交的事务所做的那些修改，这只是一个虚拟快照
3. 对于只读事务，很有用。如果你这样做的话，那么，数据库系统就不要求你去获取任何lock或者维护read set或write set，因为他有一个一致的快照，它只会看到该事务开始时已存在的那些修改，这使得那些只读事务变得⾮常⾼效，且执⾏速度也很快
4. 优点：⽀持⼀种叫做Time-Travel Query的东⻄，实际上，通过这种查询，你可以问数据库它三天前的状态是什么，或者三年前的状态是 什么。使⽤这种多版本，它们实际可以回答这些查询
#### MVCC 设计决策
##### 并发控制协议
##### 版本存储
###### append only storage
1. 每当我们创建某个数据的新版本时,我们只需复制该tuple的⽼版本，并将该副本作为我们表空间中的⼀个新物理tuple，并对其进 ⾏更新.接着，我们更新指针并说,这是该tuple的下⼀个版本
2. 思路：表中找到空slot，复制当前要更新对象的值并放入Slot中，接着将修改后值放入此slot，第二：更新指针，指向当前最新的版本
3. 可以从旧到新排序或者反则来
4. 当该数据的新版本追加到这个version chain的末尾时，我们可以很容易地追加这个新tuple，让原本指向⽼版本的指针更新，从较⽼版本指向该tuple 的新版本
5. 新到旧：你添加这个条⽬的时候（即这个tuple的新版本），要将该条⽬的指针指向原来那个头节点，但现在你需要更新全部索引，让它们指向你的新版本。索引指向的始终是version chain的头节点
6. 读取老数据
###### Time-travel storage
1. 它⾥⾯所保存的始终是对象或者tuple的最新版本,然后，我们会将这些⽼版本数据复制到⼀张单独的表上。我们将这张表叫做Time-Travel表，你需要做的就是去维护master version表中指向Time-Travel表的指针
2. 更新对象A：我们将A2复制到Time-Travel表的空闲位置，接着，我们要去更新版本指针，以此来让它指向tuple A的最⽼版本，接着，我们要去更新版本指针，以此来让它指向tuple A的最⽼版本，最后我们需要更新指针，将指向A3的指针指向我们刚在Time-Travel表中插⼊的A2
###### Delta Storage
1. 我们只需去维护那些对前⼀个版本所做的修改即可
2. 你只需将那些修改过的值复制到这张单独的Delta Storage Segment中即可
3. 为了更新A，我们⾸先要去更新它的版本号，我们要将这个值复制到右边的Delta Storage Segment表上，我们⽆须去保存完整的tuple
4. 我们只需去创建⼀个delta值，这⾥⾯存放的是该tuple中实际被修改的属性值，接着，我们会在Main表中更新实际的值。并且，我们要去更新指针，让它从这个新值指向我们的Delta Storage对应的位置
5. 如果我们现在想插⼊⼀个新值和⼀个新版本号，那么，我们需要做些和Time-Travel Table那种情况类似的事情，我们会去追加新的版本号，并更新值。但我们也需要更新A3的指针，让它指向A2的当前值
6. 我们需要去更新A2的指针，让它指向A的⽼版本，即A1
7. 适用于写入方案
##### 垃圾回收
##### 元组级别垃圾回收
1. 本质上来讲，我们会对我们的表进⾏循序扫描，以此来弄清楚这些tuple是否对它们可⻅。通过判断事务的时间戳是否在Begin和end期间
2. 通过使⽤版本时间戳和那些活跃的事务来弄清楚这些版本是否过期
3. 如果它过期了，那么我们就会将它清除
4. 事实上很复杂，因为我们不仅要去查看内存中的那些page数据，我们还要去查看那些交换到磁盘上的那些page，因为我们想去清除所有垃圾
5. 实际上，我们可以为那些dirty page维护⼀个bitmap,每当你更新数据时,你可以翻转你所修改的那个page对应的bit
6. 虽然需要额外的空间，对于数据库中的所有page来说，它们共⽤⼀个bitmap
###### Cooperative Cleaning
1. 当它们遇上这些旧版本数据的时候，就把这些数据清理掉
2. 你们要记住Cooperative Cleaning只适⽤于从旧到新这种顺序
3. 通过索引找到对象A，它会落在version chain的头节点处，即A的最旧值处，接着，它会沿着这个对象的version chain进⾏扫描，来弄清楚实际该数据的哪个版本对其可⻅，哪个版本对事务不可见标记为删除，并回收所占用的空间（实际还没有去回收），最后更新索引，让它指向这个Version chain的新头节点
4. 在物理删除这些数据或者回收这些空间之前，实际上你可以更新索引指针，让它指向A2

##### 事务级别垃圾回收
1. 但它的基本思路是你的事务会去维护它们的read set和write set，当这些事务提交的时候，你可以弄清楚，当它们不再可⻅的时候，你就可以清理它们了
2. 我们只需去维护事务的read/write set，我们通过它们来弄清楚哪些版本数据不再可⽤，然后，我们去回收这些空间. 
##### 索引管理
1. 主键索引指向的永远是version chain的头节点，每当我们去创建某个新版本数据时，我们需要去更新该数据对应的version chain，我们需要对索引进⾏更新，以让它指向该version chain的新头节点
##### secondary indexs
###### 逻辑指针
1. 我们通过维护⼀个逻辑指针来确保我们的索引反映了version chain中的正确值
2. 每个tuple都会有⼀个唯⼀标识符，它是不会改变的，接着，你会有⼀个indirection layer（间接层）
3. 间接层所做的事情是将tuple的逻辑id映射到数据库中的物理位置
4. 每当你要更新version chain的时候，你只需要去更新这个间接层即可，⽽⽆需去更新每个索引
5. 思路：⾸先你需要通过主键索引查找，⽽不是⾮主键索引，当你想知道物理地址是什么的时候事情，你需要在主键索引中进⾏查找，所有的操作流程都与第⼀个例⼦中的物理地址相关部分相同。每当我更新tuple和它所对应的version chain的头节点时，你可以只更新主键索引，也就⾃动更新了所有的⾮主键索引。这是mysql的做法，psql保存的是物理地址
###### demo
1. 你会通过⾮主键索引来获取tuple id,接着，你通过tuple id来弄清楚它的物理地址是什么
2. 这⾥的hash table会告诉你该tuple的物理地址是什么，
###### 物理指针
1. 即它直接指向的是version chain的头节点
2. 每当version chain更新的时候，你需要更新每个索引
#### 难点
1. 索引管理
