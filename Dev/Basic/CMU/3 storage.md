#### 存储一
##### 为什么不适用OS
1. OS会造成页面错误，导致IO读取速率下降。因为页面未命中的话需要从磁盘拿。这时候不得不不让数据系统停止请求该Page的线程
2. 本质上来讲操作系统并不知道我们要做什么，它也不知道数据库要做什么
3. DBMS能做到的
#### Four
##### 非易失性内存
1. 由英特尔首先生产出，名傲腾
根据PPT的问题进行学习

#### 场景分析
##### 数据库崩溃
1. 当数据库崩溃了是否有什么方式定位到崩溃的原因：checksum，我去查最后一个page页面中所计算出的checksum的值是否和预定的值不匹配

##### 写入一组数据，删除中间中的一个再插入新的

1. SQL SERVER：检测有空间会将Page变得紧凑，然后再进行写入
2. `Postgrep和Oracle`：会进行放空在后面写入

##### 为什么暴露这个API给用户

1. 可以通过存储位置进行访问元组，但是不想做，因为在任意时候，数据库系统被允许去重新组织ctid，最终会得到一个不同的`ctid`
2. 将系统内部的东西暴露出来，可以让我们清楚发生了什么

 
#### 文件存储
1. 以专有格式将数据库存储未磁盘上的一个或多个文件
2. 一个页存储着所有页面的元数据
3. 不会在一个页面存储着不同类型的数据
##### 存储管理
1. 存储管理的责任就是维护数据库文件
2. 对读写做一些调度进行提高时间和空间的局限性
3. 文件的结构是一系列页面的集合，跟踪读写页面，并记录可用的空间
#### 数据库页面
1. 存储设备只能保证每次写入4kb时是原子的
2. DBMS使用间接层将pageID to 物理位置
3. 4kb：SQL lite oracle; 8 kb : sql server postgresql; 16 kb mysql
4. 页面大的原因可以减少page表的Page ID数目，从而在TLB中缓存ID减少未命中
##### 堆文件
1. 无序页面集合
2. 支持迭代所有页面，如果只有一个文件，可以很容易的找到页面
3. 需要元数据跟踪哪个页面存在于多个文件，哪个页面有空余的空间
4. 堆文件中有两个指针，一个指向空闲页面列表、一个指向数据页面列表
##### 堆文件：页面目录
1. Self-contained:表示的是我们需要的所有元数据都在这个page上
2. 确保目录页面和数据页面同步
3. 页面目录也会记录可用空间的元数据，每个页面的空槽数，空页面的数
#### Page layout
##### Page Header
1. 每个文件包含关于页面内容的元数据的头部：页面大小
2. 
3. 

##### 元组存储
如果长度不是固定：想插入的位置可能就没有足够的空间去保存那个tuple
当删除元组时：元数据会告诉我们在page上的某个位置，可以写入数据或者通过对这个page进行循序扫描，然后找到能插入tuple位置

##### 槽页面
1. Slot数组将一个特定的slot映射到page上的某个偏移量上，根据偏移量找到想要的tuple，偏移量指的是：tuple的大小；slot是0还是1取决于你的起点偏移量
2. 填充page方式：从前往后对slot数组进行填充，数据则从后往前填充，在某些时候我们的数据占用了该一半大小的页面，就再也无法存入任何信息
3. 使用`vaccum full`操作这是Postgres中的一个操作用于整理数据库或者压缩，也可以对数据库进行扫描并整理碎片
###### 数据整理
1. Postgres删除后再添加会是追加写入，通过vacuum full命令会进行整理然后按顺序
2. `Sql server` :删除后再添加，还是会写入空槽

## 数据库存储下
#### 场景
##### 这个结果是一直四舍五入还是最后才四舍五入
1. 在客户端进行四舍五入

### 日志结构文件组织
1. 追加写入日志（增删改）
2. 可以快速回滚
#### 提高读取速度
1. 建立索引，表示想找到这个元组，重新走一遍，对里面的内容进行筛选压缩，对每个记录只需要知道一条即可
2. 应用场景HBase、cassandra
#### 数据的表现
1. ⼀个tuple就是⼀个字节序列，就是⼀个字节数组
2. 基本上来讲，IEEE-754是⼀种⾏业标准，它是⼀种⽤来表示数字和CPU的规范，使用二进制补码来表示
3. 对于那些可变⻓度的类型，例如varchar，varbinary，text以及blob来说，通常情况下，它们⾥⾯都有⼀个header，它⾥⾯会保存我所保存的blob的⻓度，如果它是⼀个很⼤很⼤的值，那后⾯还会跟⼀个checksum，接着，后⾯就跟的是字节序列
4. 
#### 可变精度
1. CPU能够⾼效执⾏这些操作的指令
2. 对可变精度数字执⾏操作的速度要⽐任意精度数字快得多，但是会在高精度时显示误差: float和double
3. 硬件没有办法精确表示浮点数
##### 固定精度
1. ``` copy tableName  from 'file path' delimiter ',' csv; ```在Postgres中复制到表中，不同系统有不同的命令
2. explain 在前面给出语句的执行计划
3. ```explain analyze ```:给出查询计划并执行
4. oracle默认使用定点数处理，
##### Numeric
1. 在Postgrep使用了Switch语句进行实现
##### 巨大的值
1. 大多数DBMS不允许单个元组超过单个页面
2. 将溢出的元组添加到其他页面需要对溢出页面进行维护，
方案二使用外部存储
1. 在元组中存储一个指针或是一个文件路径
2. 不能进行写入操作只能进行读操作，也没有事务保护、可能会被外部操作文件
3. 使用外部的原因：比如视频，
#### 系统目录
1. MYSQL无法阻止人跑到mysql目录下进行修改
2. 指的是系统的元数据
3. 在运行时编译或者代码生成，比如JIT；oracle、新版postgrep、sql server采用了，mysql没有
#### 存储模型
##### 联机事务处理
1. 我们从外⾯的世界拿到新数据后，将它们放⼊我们的数据库系统
2. 只会去读取⼀⼩部分数据或者更新⼀⼩部分数据
3. 从收集的信息，分析并从中推断出新的信息
##### OLAP
1. 大量的读操作，但是会更复杂
##### NOSQL
1. 靠近OLTP层，主要往里面塞入数据
##### MySQL
1. MySQL和Postfre支持OLAP类别的查询
##### HBase、BigTable和Hadoop
1. 他们并不去执⾏SQL，也不会进⾏事务处理，更不会进⾏Join操作
##### NEWSQL
1. ⼈们意识到他们想要处理事务的能⼒，想要SQL，也想去进⾏某些Join操作
##### N-ary存储模型
1. 就是行存储
2. 使用连续存储在Page中
3. 体积较大的对象，使用Overflow
##### 使用列级存储的原因
1. 有时候检索时只需要一列的数据，而行级数据
##### 列级存储
1. 需要查询所有的
##### 压缩算法
Gzip
### 存储3
1. 没有特别的要求一个元组所有的属性都存在一个页面
2. 
#### 




