#### 第一章 操作系统接口
一个操作系统的工作是在多个程序之间共享计算机资源，并提供比硬件本身更有用的服务。操作系统管理和抽象低层次的硬件，以便例如文字处理器不必关心使用的磁盘硬件类型。操作系统共享硬件资源，使得多个程序可以同时运行（或看起来是同时运行）。最后，操作系统提供受控的程序交互方式，以便它们可以共享数据或协同工作。操作系统通过接口向用户程序提供服务。设计一个好的接口事实证明非常困难。一方面，我们希望接口简单窄化，因为这样可以更容易地实现正确性。另一方面，我们可能会被诱惑向应用程序提供许多复杂的特性。解决这种紧张局势的技巧是设计依赖于一些可以结合起来提供很高通用性的机制的接口。本书使用一个操作系统作为具体示例来说明操作系统的概念。该操作系统xv6提供了由Ken Thompson和Dennis Ritchie的Unix操作系统介绍的基本接口，同时模仿Unix的内部设计。Unix提供了一个窄接口，其机制组合得很好，提供了出乎意料的通用性。这个接口如此成功，以至于现代操作系统 - BSD，Linux，macOS，Solaris，甚至在较小程度上的Microsoft Windows都具有类似Unix的接口。理解xv6是理解任何这些系统和许多其他系统的良好起点。

如图1.1所示，xv6采用内核的传统形式，即提供服务于运行程序的特殊程序。每个运行的程序称为进程，具有包含指令、数据和堆栈的内存。指令实现程序的计算，数据是计算作用的变量，堆栈组织程序的过程调用。一台计算机通常有许多进程，但只有一个内核。当进程需要调用内核服务时，它会调用系统调用，即操作系统接口中的其中一个调用。系统调用进入内核，内核执行服务并返回。因此，进程在用户空间和内核空间之间交替执行。
内核使用 CPU 提供的硬件保护机制，确保在用户空间执行的每个进程只能访问自己的内存。内核在具有实施这些保护所需的硬件特权的情况下执行；用户程序则没有这些特权。当用户程序调用系统调用时，硬件会提升特权级别并开始在内核中执行预先安排的函数。

内核提供的系统调用集合是用户程序看到的接口。xv6 内核提供了传统 Unix 内核通常提供的服务和系统调用的子集。图1.2 列出了 xv6 的所有系统调用。

本章的其余部分概述了 xv6 的服务-进程、内存、文件描述符、管道和文件系统，并使用代码片段和讨论说明了它们以及 shell 如何使用它们。shell 对系统调用的使用说明了它们设计得非常小心。

shell 是一个普通的程序，从用户读取命令并执行它们。shell 是用户程序而不是内核的一部分，说明了系统调用接口的强大之处：shell 没有任何特殊之处。这也意味着 shell 很容易被替换；因此，现代 Unix 系统有多种 shell 可供选择，每种 shell 都有自己的用户界面和脚本功能。xv6 shell 是 Unix Bourne shell 本质的简单实现。其实现可以在（user/sh.c：1）中找到。
###### 1.1 处理器和内存
一个 xv6 进程由用户空间内存（指令、数据和堆栈）和内核私有的进程状态组成。xv6 对进程进行时间共享：它在等待执行的进程集合之间透明地切换可用的 CPU。当一个进程没有执行时，xv6 保存它的 CPU 寄存器，在下次运行该进程时恢复它们。内核为每个进程关联一个进程标识符（PID）。

一个进程可以使用 fork 系统调用创建一个新进程。Fork 创建一个新进程，称为子进程，其内存内容与调用进程（称为父进程）完全相同。fork 在父进程和子进程中都返回。在父进程中，fork 返回子进程的 PID；在子进程中，fork 返回零。例如，考虑以下用 C 编程语言编写的程序片段 [6]：
int pid = fork(); if(pid > 0){ printf("parent: child=%d\n", pid);
```c++
Figure 1.2: Xv6 system calls. If not otherwise stated, these calls return 0 for no error, and -1 if there’s an error. 
pid = wait((int *) 0); printf("child %d is done\n", pid); } 
else if(pid == 0){ 
printf("child: exiting\n"); exit(0); } 
else { printf("fork error\n"); }
```
exit 系统调用会导致调用进程停止执行并释放诸如内存和打开的文件等资源。exit 接受一个整数状态参数，通常为 0 表示成功，1 表示失败。wait 系统调用返回当前进程已退出（或被杀死）的子进程的 PID，并将子进程的退出状态复制到传递给 wait 的地址；如果调用者的任何子进程都没有退出，则 wait 等待其中一个子进程退出。如果调用者没有子进程，则 wait 立即返回 -1。如果父进程不关心子进程的退出状态，则可以将一个 0 地址传递给 wait。上个代码输出：
```
parent: child= 1234
child: exiting
```
这两个 printf 调用可能以任意顺序出现，这取决于父进程或子进程先到达其 printf 调用。子进程退出后，父进程的 wait 返回，导致父进程打印：
```
parent:child 1234 is done
```
虽然子进程最初具有与父进程相同的内存内容，但父进程和子进程使用不同的内存和不同的寄存器执行：在一个进程中更改变量不会影响另一个进程。例如，当将 wait 的返回值存储到父进程的 pid 变量中时，它不会更改子进程中的 pid 变量。子进程中 pid 的值仍将为零。

exec 系统调用使用存储在文件系统中的文件加载一个新的内存映像来替换调用进程的内存。该文件必须具有特定的格式，指定哪个部分存储指令，哪个部分是数据，从哪个指令开始等。xv6 使用 ELF 格式，第 3 章对其进行了更详细的讨论。当 exec 成功时，它不会返回到调用程序；相反，从文件中加载的指令从 ELF 标头中声明的入口点开始执行。exec 接受两个参数：包含可执行文件的文件名和一个字符串参数数组。例如：
```c++
char *argv[3]; 
argv[0] = "echo"; 
argv[1] = "hello"; 
argv[2] = 0; 
exec("/bin/echo", argv); printf("exec error\n");
```
这个片段用 /bin/echo 程序的实例替换调用程序，并使用参数列表 echo hello 运行。大多数程序忽略参数数组的第一个元素，该元素通常是程序的名称。

xv6 shell 使用上述调用代表用户运行程序。 shell 的主要结构很简单；请参阅 main (user/sh.c:145)。主循环从用户那里读取一行输入，然后使用 getcmd 调用 fork，创建 shell 进程的副本。父进程调用 wait，而子进程运行命令。例如，如果用户在 shell 中输入“echo hello”，则 runcmd 将以“echo hello”作为参数被调用。runcmd (user/sh.c:58) 运行实际命令。对于“echo hello”，它会调用 exec (user/sh.c:78)。如果 exec 成功，则子进程将执行 echo 的指令，而不是 runcmd。在某个时候，echo 将调用 exit，这将导致父进程从 main (user/sh.c:145) 中的 wait 返回。

您可能会想知道为什么 fork 和 exec 没有合并为一个调用；我们将在后面看到 shell 在实现 I/O 重定向时利用了这种分离。为避免创建重复的进程并立即用 exec 替换它的浪费，操作系统内核优化了 fork 的实现，使用虚拟内存技术，如写时复制（参见第 4.6 节）。
Xv6隐式分配了大多数用户空间内存：fork分配了子进程所需的父进程内存副本的内存，而exec分配了足够的内存来容纳可执行文件。在运行时需要更多内存（例如用于malloc）的进程可以调用sbrk（n）来增加其数据内存n个字节；sbrk返回新内存的位置。
##### 1.2 IO和文件描述符
文件描述符是表示进程可以从中读取或写入的内核管理对象的小整数。进程可以通过打开文件、目录或设备，创建管道或复制现有描述符来获得文件描述符。为简单起见，我们经常将文件描述符引用的对象称为“文件”；文件描述符接口抽象了文件、管道和设备之间的差异，使它们都看起来像字节流。我们将输入和输出称为 I/O。

在内部，xv6内核将文件描述符用作进程表中的索引，以便每个进程从零开始具有私有的文件描述符空间。按照惯例，进程从文件描述符0（标准输入）读取，将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。正如我们将看到的那样，shell利用这个约定来实现I/O重定向和管道。 shell确保始终打开三个文件描述符（user/sh.c:151），它们默认为控制台的文件描述符。

read和write系统调用从由文件描述符命名的打开文件中读取字节并写入字节。调用read（fd，buf，n）最多从文件描述符fd中读取n个字节，将它们复制到buf中，并返回读取的字节数。每个引用文件的文件描述符都有一个关联的偏移量。读取从当前文件偏移量读取数据，然后将该偏移量向前移动读取的字节数：后续的读取将返回第一个读取返回的字节之后的字节。当没有更多要读取的字节时，read返回零以表示文件的结尾。

调用write（fd，buf，n）将从buf中写入n个字节到文件描述符fd，并返回已写入的字节数。只有在发生错误时才会写入少于n个字节。与read一样，write将数据写入当前文件偏移量，然后将该偏移量向前移动写入的字节数：每次写入都从上一个写入的位置开始。

以下程序片段（构成程序cat的核心部分）将数据从标准输入复制到标准输出。如果发生错误，则向标准错误写入一条消息。
```c++
char buf[512]; 
int n; 
for(;;){ n = read(0, buf, sizeof buf); 
if(n == 0) break; 
if(n < 0){ fprintf(2, "read error\n"); exit(1); 
}
if(write(1, buf, n) != n){ 
fprintf(2, "write error\n");
exit(1); } }
```
代码片段中需要注意的重要事项是，cat不知道它是从文件、控制台还是管道中读取数据。同样，cat不知道它是将输出打印到控制台、文件还是其他地方。使用文件描述符和文件描述符0是输入，文件描述符1是输出的约定，使cat的实现变得简单。

close系统调用释放文件描述符，使其可供将来的open、pipe或dup系统调用重用（见下文）。新分配的文件描述符始终是当前进程中未使用的最低编号的描述符。

文件描述符和fork相互作用，使得I/O重定向易于实现。fork复制父进程的文件描述符表以及其内存，使得子进程从与父进程完全相同的打开文件开始。系统调用exec替换调用进程的内存，但保留其文件表。这种行为允许shell通过fork、在子进程中重新打开选择的文件描述符，然后调用exec运行新程序来实现I/O重定向。这是shell运行命令cat <input.txt时的简化代码版本。
```c++
char *argv[2]; 
argv[0] = "cat"; 
argv[1] = 0; 
if(fork() == 0) { close(0); 
open("input.txt", O_RDONLY); exec("cat", argv); }
```
在子进程关闭文件描述符0之后，open保证使用该文件描述符来打开新的input.txt：0将是最小的可用文件描述符。然后，cat使用文件描述符0（标准输入）引用input.txt来执行。由于这个序列只修改了子进程的描述符，所以父进程的文件描述符没有被改变。

xv6 shell中的I/O重定向代码以完全相同的方式工作（user/sh.c:82）。回想一下，在代码的这一点上，shell已经fork了子shell，并且runcmd将调用exec来加载新程序。

open的第二个参数由一组标志表示，以位为单位，控制open的行为。可能的值在文件控制（fcntl）头文件（kernel/fcntl.h:1-5）中定义：O_RDONLY，O_WRONLY，O_RDWR，O_CREATE和O_TRUNC，它们指示open打开文件进行读取，写入或读取和写入，如果文件不存在，则创建文件，并将文件截断为零长度。
现在应该清楚为什么fork和exec是分开调用的，这对于shell来说非常有帮助：在两个调用之间，shell有机会重定向子进程的I/O而不干扰主shell的I/O设置。也可以想象一个假想的组合fork-exec系统调用，但是使用这样的调用进行I/O重定向的选项似乎很笨拙。shell可以在调用forkexec之前修改自己的I/O设置（然后撤销这些修改）；或者forkexec可以将I/O重定向的指令作为参数传递；或者（最不吸引人的）像cat这样的每个程序都可以被教导如何进行自己的I/O重定向。

尽管fork复制了文件描述符表，但每个底层文件偏移量在父进程和子进程之间是共享的。考虑以下示例：
```c++
if(fork() == 0) { 
    write(1, "hello ", 6); 
    exit(0); } 
else { 
    wait(0); 
     write(1, "world\n", 6); }
```
